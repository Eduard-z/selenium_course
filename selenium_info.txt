Selenium — это проект, который предназначен главным образом для автоматизации тестирования веб-приложений.
По сути своей это — универсальный интерфейс, который позволяет манипулировать разными браузерами напрямую из кода на языке программирования.

Для поиска элементов на странице в Selenium WebDriver используются несколько стратегий:
find_element_by_id - поиск по уникальному атрибуту id элемента. Если ваши разработчики проставляют всем элементам в приложении уникальный id, то вам повезло, и вы чаще всего будет использовать этот метод, так как он наиболее стабильный;
find_element_by_css_selector - поиск элемента с помощью правил на основе CSS. Это универсальный метод поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете использовать именно этот метод в ваших тестах;
find_element_by_xpath - поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск элементов;
find_element_by_name - поиск по атрибуту name элемента;
find_element_by_tag_name - поиск элемента по названию тега элемента;
find_element_by_class_name - поиск по значению атрибута class;
find_element_by_link_text - поиск ссылки на странице по полному совпадению;
find_element_by_partial_link_text - поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.

Системы UNIX/Linux ожидают пустую строку в конце файла, если в вашем скрипте ее не будет, то последняя строчка, содержащая код, может не выполниться.

checkbox и radiobutton
Если checkbox или radiobutton выбран, то у элемента появится новый атрибут checked без значения:
<input type="checkbox" checked>
<input type="radio" checked>
Radiobuttons объединяются в группу, где все элементы имеют одинаковые значения атрибута name, но разные значения атрибута value:
<input type="radio" name="language" value="python" checked>
<input type="radio" name="language" value="selenium">
Также вы можете увидеть тег label рядом с input. Этот тег используется, чтобы сделать кликабельным текст, который отображается рядом с флажком. Этот текст заключен внутри тега label. Элемент label связывается с элементом input с помощью атрибута for, в котором указывается значение атрибута id для элемента input:
<div>
	<input type="radio" id="python" name="language" checked>
	<label for="python">Python</label>
</div>
Для более детальных проверок в тесте нам может понадобиться узнать значение атрибута элемента. Значение атрибута представляет собой строку. Если значение атрибута отсутствует, то это равносильно значению атрибута равному "false".
	people_checked = people_radio.get_attribute("checked")
	assert people_checked == "true", "People radio is not selected by default"
Если атрибута нет, то метод get_attribute вернёт значение None.
Так же мы можем проверять наличие атрибута disabled, который определяет, может ли пользователь взаимодействовать с элементом.

dropdown
1. У каждого элемента списка обычно есть уникальное значение атрибута value;
2. В списках может быть разрешено выбирать как только один, так и несколько вариантов, в зависимости от типа списка;
3. Визуально списки могут различаться тем, что в одном случае все варианты скрыты в выпадающем меню, а в другом все варианты или их часть видны.

<label for="dropdown">Выберите язык программирования:</label>
<select id="dropdown" class="custom-select">
	<option selected>--</option>
	<option value="1">Python</option>
	<option value="2">Java</option>
	<option value="3">JavaScript</option>
</select>
Можно отмечать варианты с помощью обычного метода click(). Для этого сначала нужно применить метод click() для элемента с тегом select, чтобы список раскрылся, а затем кликнуть на нужный вариант ответа.
Есть более удобный способ, для которого используется специальный класс Select из библиотеки WebDriver. Вначале мы должны инициализировать новый объект, передав в него WebElement с тегом select. Далее можно найти любой вариант из списка с помощью метода select_by_value(value):

	from selenium.webdriver.support.ui import Select
	select = Select(browser.find_element_by_tag_name("select"))
	select.select_by_value("1") # ищем элемент с текстом "Python"
Можно использовать еще два метода: select.select_by_visible_text("text") и select.select_by_index(index). 


Метод execute_script:
	from selenium import webdriver
	browser = webdriver.Chrome()
	browser.execute_script("alert('Robots at work');")
	
чтобы кликнуть на перекрытую кнопку, нам нужно выполнить следующие команды в коде:
	button = browser.find_element_by_tag_name("button")
	browser.execute_script("return arguments[0].scrollIntoView(true);", button)
	button.click()
	
Также можно проскролить всю страницу целиком на строго заданное количество пикселей:
	browser.execute_script("window.scrollBy(0, 100);")
	

Загрузка файлов
	import os 
	current_dir = os.path.abspath(os.path.dirname(__file__))    # получаем путь к директории текущего исполняемого файла 
	file_path = os.path.join(current_dir, 'test_file.txt')      # добавляем к этому пути имя файла (в той же папке)
	element.send_keys(file_path)
Элемент в форме, который выглядит, как кнопка добавления файла, имеет атрибут type="file".

alert
Alert является модальным окном: это означает, что пользователь не может взаимодействовать дальше с интерфейсом, пока не закроет alert. Для этого нужно сначала переключиться на окно с alert, а затем принять его с помощью команды accept():

	alert = browser.switch_to.alert
	alert.accept()
Чтобы получить текст из alert, используйте свойство text объекта alert:

	alert = browser.switch_to.alert
	alert_text = alert.text
Другой вариант модального окна, который предлагает пользователю выбор согласиться с сообщением или отказаться от него, называется confirm. Для переключения на окно confirm используется та же команда, что и в случае с alert - confirm.accept(). Для confirm-окон можно использовать следующий метод для отказа:

	confirm.dismiss()

Третий вариант модального окна — prompt — имеет дополнительное поле для ввода текста. Чтобы ввести текст, используйте метод send_keys():

	prompt = browser.switch_to.alert
	prompt.send_keys("My answer")
	prompt.accept()

window
При открытии новой вкладки WebDriver продолжит работать со старой вкладкой. Для переключения на новую вкладку надо явно указать, на какую вкладку мы хотим перейти. Это делается с помощью команды switch_to.window:

	browser.switch_to.window(window_name)
	
Чтобы узнать имя новой вкладки, нужно использовать метод window_handles, который возвращает массив имён всех вкладок. Зная, что в браузере теперь открыто две вкладки, выбираем вторую вкладку:

	new_window = browser.window_handles[1]

Также мы можем запомнить имя текущей вкладки, чтобы иметь возможность потом к ней вернуться:

	first_window = browser.window_handles[0]
Текущую вкладку можно узнать так:

	current_window = browser.current_window_handle

Implicit Waits
Ожидание называется неявным (Implicit wait), так как его не надо явно указывать каждый раз, когда мы выполняем поиск элементов, оно автоматически будет применяться при вызове каждой последующей команды:

	browser.implicitly_wait(5)

На каждый вызов команды find_element WebDriver будет ждать 5 секунд до появления элемента на странице прежде, чем выбросить исключение NoSuchElementException. 
Во время поиска WebDriver каждые 0.5 секунды проверяет, появился ли нужный элемент в DOM-модели браузера (Document Object Model — «объектная модель документа», интерфейс для доступа к HTML-содержимому сайта). Если произойдет ошибка, то WebDriver выбросит одно из следующих исключений (exceptions):
1. Если элемент не был найден за отведенное время, то мы получим NoSuchElementException.
2. Если элемент был найден в момент поиска, но при последующем обращении к элементу DOM изменился, то получим StaleElementReferenceException. Например, мы нашли элемент Кнопка и через какое-то время решили выполнить с ним уже известный нам метод click. Если кнопка за это время была скрыта скриптом, то метод применять уже бесполезно — элемент "устарел" (stale) и мы увидим исключение.
3. Если элемент был найден в момент поиска, но сам элемент невидим (например, имеет нулевые размеры), и реальный пользователь не смог бы с ним взаимодействовать, то получим ElementNotVisibleException.

Explicit Waits
Кнопка может быть неактивной, может быть перекрыта каким-то другим элементом или быть невидимой. Чтобы тест был надежным, нам нужно не только найти кнопку на странице, но и дождаться, когда кнопка станет кликабельной. 

	from selenium.webdriver.common.by import By
	from selenium.webdriver.support.ui import WebDriverWait
	from selenium.webdriver.support import expected_conditions as EC
	from selenium import webdriver

	browser = webdriver.Chrome()
	browser.get("http://suninjuly.github.io/wait2.html")

	# говорим Selenium проверять в течение 5 секунд, пока кнопка не станет кликабельной
	button = WebDriverWait(browser, 5).until(
			EC.element_to_be_clickable((By.ID, "verify"))
		)
	button.click()
	
element_to_be_clickable вернет элемент, когда он станет кликабельным, или вернет False в ином случае. Если мы захотим проверять, что кнопка становится неактивной после отправки данных, то можно задать негативное правило с помощью метода until_not.

Составные сообщения об ошибках
Если вы проверяете наличие элемента, то обязательно пишите, что это за элемент по смыслу на странице: 

	assert self.is_element_present('create_class_button', timeout=30), "No create class button"

Если элемент встречается на нескольких страницах приложения, не лишним будет указать, где именно произошла ошибка: 

	assert self.is_element_present('new_announcement_button', timeout=30), "No new announcement button on profile page"
	
Если вы работаете с каким-то текстом (например, проверяете информационное сообщение, текущий url, ссылку, placeholder в input-элементе или любой другой текст), в сообщении об ошибке всегда лучше выводить оба значения: то, которое ожидалось, и то, которое получили по факту. Всё как в хорошем багрепорте: ожидаемый и фактический результат.

Еще один важный момент: когда вы работаете с текстом элементов на странице или любым другим контентом, который может измениться, всегда записывайте его в отдельную переменную для сравнения. 

неправильно: 

	assert self.catalog_link.text  == "Каталог", \
		f"Wrong language, got {self.catalog_link.text} instead of 'Каталог'" 
Дважды считывать атрибут — это плохая практика, потому что при повторном считывании текст на странице может измениться, и вы получите неактуальный текст об ошибке. Результат выполнения такого теста сложно анализировать: 
	"Wrong language, got 'Каталог' instead of 'Каталог'"

правильно: 

	catalog_text = self.catalog_link.text 		# считываем текст и записываем его в переменную
	assert catalog_text == "Каталог", \
		f"Wrong language, got {catalog_text} instead of 'Каталог'"
		
unittest
1. Импортировать unittest в файл: import unittest;
2. Создать класс, который должен наследоваться от класса TestCase: class TestAbs(unittest.TestCase);
3. Превратить тестовые функции в методы, добавив ссылку на экземпляр класса self в качестве первого аргумента функции: def test_abs1(self);
4. Изменить assert на self.assertEqual();
5. Заменить строку запуска программы на unittest.main().

PyTest
1) PyTest полностью обратно совместим с фреймворками unittest и nosetest;
2) Подробный отчёт с поддержкой цветовых схем из коробки;
3) PyTest не требует написания дополнительных специфических конструкций в тестах, как того требует unittest (no boilerplate);
4) Для проверок используется стандартный assert из Python;
5) Возможность создания динамических фикстур (специальных функций, которые настраивают тестовые окружения и готовят тестовые данные);
6) Дополнительные возможности по настройке фикстур;
7) Параметризация тестов — для одного теста можно задать разные параметры (тест запустится несколько раз с разными тестовыми данными);
8) Наличие маркировок (marks), которые позволяют маркировать тесты для их выборочного запуска;
9) Возможность передавать дополнительные параметры через командную строку для настройки тестовых окружений;
10) Большое количество плагинов, которые расширяют возможности PyTest.

Рассмотрим минусы PyTest:
1) PyTest требуется устанавливать дополнительно, так как он не входит в стандартный пакет библиотек Python, в отличие от unittest. Нужно не забывать об этом, когда вы будете настраивать автоматический запуск тестов с помощью CI-сервера.
2) Использование PyTest требует более глубокого понимания языка Python, чтобы разобраться, как применять фикстуры, параметризацию и другие возможности PyTest.
